import { AxiosClient } from '@/modules/common/infrastructure/api/axios-client';
import { type ApiResponse, type PaginatedApiResponse } from '@/types/ApiResponse';
import { type {entity} } from '../../domain/entities/{entity}';

import { type {entity}RepositoryInterface } from '../../domain/interfaces/{entity}RepositoryInterface';

export class {entity}Repository implements {entity}RepositoryInterface {
  private readonly client: AxiosClient;

  constructor() {
    this.client = new AxiosClient();
  }

  private async fetchCsrf(): Promise<void> {
    await this.client.get('/sanctum/csrf-cookie');
  }

  async create{entity}({entityCamel}: Omit<{entity}, 'id' | 'createdAt' | 'updatedAt'>): Promise<ApiResponse<{entity}>> {
    try {
      await this.fetchCsrf();
      return await this.client.post<{entity}>('/api/v1/{moduleKebab}/{entityKebabPlural}', {entityCamel});
    } catch (error: unknown) {
      return this.handleError<{entity}>(error, '{entitySnakeUpper}_CREATE_ERROR', 'Failed to create {entityCamel}');
    }
  }

  async get{entity}(id: string | number): Promise<ApiResponse<{entity}>> {
    try {
      return await this.client.get<{entity}>(`/api/v1/{moduleKebab}/{entityKebabPlural}/${id}`);
    } catch (error: unknown) {
      return this.handleError<{entity}>(error, '{entitySnakeUpper}_FETCH_ERROR', 'Failed to fetch {entityCamel}');
    }
  }

  async update{entity}(
    id: string | number,
    {entityCamel}: Partial<Omit<{entity}, 'id' | 'createdAt' | 'updatedAt'>>
  ): Promise<ApiResponse<{entity}>> {
    try {
      await this.fetchCsrf();
      const payload = { ...{entityCamel} };
      return await this.client.put<{entity}>(`/api/v1/{moduleKebab}/{entityKebabPlural}/${id}`, payload);
    } catch (error: unknown) {
      return this.handleError<{entity}>(error, '{entitySnakeUpper}_UPDATE_ERROR', 'Failed to update {entityCamel}');
    }
  }

  async delete{entity}(id: string | number): Promise<ApiResponse<null>> {
    try {
      await this.fetchCsrf();
      return await this.client.delete<null>(`/api/v1/{moduleKebab}/{entityKebabPlural}/${id}`);
    } catch (error: unknown) {
      return this.handleError<null>(error, '{entitySnakeUpper}_DELETE_ERROR', 'Failed to delete {entityCamel}');
    }
  }

  async paginate(
    search = '',
    searchFields: string[] = [],
    relations: string[] = [],
    filters: Record<string, string[]> = {},
    page = 1,
    perPage = 10
  ): Promise<ApiResponse<PaginatedApiResponse<{entity}[]>>> {
    try {
      const parameters = new URLSearchParams({
        page: String(page),
        perPage: String(perPage),
        ...(search && { search }),
      });

      for (const field of searchFields) {
        parameters.append('searchFields[]', field);
      }

      for (const relation of relations) {
        parameters.append('include[]', relation);
      }

      for (const [key, values] of Object.entries(filters)) {
        for (const value of values) {
          parameters.append(`filter[${key}][]`, value);
        }
      }

      return await this.client.get<PaginatedApiResponse<{entity}[]>>(`/api/v1/{moduleKebab}/{entityKebabPlural}`, {
        params: parameters,
      });
    } catch (error: unknown) {
      return this.handleError<PaginatedApiResponse<{entity}[]>>(
        error,
        '{entitySnakeUpper}_LIST_ERROR',
        'Failed to fetch {entityCamelPlural}'
      );
    }
  }

  private handleError<T>(error: unknown, code: string, defaultMessage: string): ApiResponse<T> {
    const responseError =
      error instanceof Error && 'response' in error ? (error as any).response : null;
    const errorData = responseError?.data?.error ?? responseError?.data;

    return {
      data: null,
      error: {
        code: errorData?.code ?? code,
        details: errorData?.details ?? null,
        message: errorData?.message ?? (error instanceof Error ? error.message : defaultMessage),
      },
      message: errorData?.message ?? (error instanceof Error ? error.message : defaultMessage),
      success: false,
    };
  }
}
